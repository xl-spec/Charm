class KeyHandler {
    constructor() {
      this.movement = { left: false, right: false, up: false, down: false };
    }
  
    handleKeyPressed(key) {
      if (key === 'a') this.movement.left = true;
      if (key === 'd') this.movement.right = true;
      if (key === 'w') this.movement.up = true;
      if (key === 's') this.movement.down = true;
    }
  
    handleKeyReleased(key) {
      if (key === 'a') this.movement.left = false;
      if (key === 'd') this.movement.right = false;
      if (key === 'w') this.movement.up = false;
      if (key === 's') this.movement.down = false;
    }
  
    getMovement() {
      return this.movement;
    }
  }
  

class Level {
    constructor(width, height, depth) {
      this.size = { width, height, depth };
    }
  
    draw() {
      push();
      translate(0, 0, 0); // Center the level at the origin
      noFill();
      stroke(255); // Outline color
      box(this.size.width, this.size.height, this.size.depth); // Render the container box
      pop();
    }
  }
  

class MouseHandler {
    constructor(camera) {
      this.dragStart = null;
      this.angleX = 0; // Horizontal rotation angle
      this.angleY = -60.4; // Vertical rotation angle
      this.zoomLevel = 20; // Initial zoom level
      // this.camera = camera; maybe add later idk
    }
  
    mousePressed() {
      // Track the initial mouse position on press
      this.dragStart = { x: mouseX, y: mouseY };
    }
  
    mouseDragged() {
      if (this.dragStart) {
        // Calculate the difference between the current and initial mouse positions
        let deltaX = mouseX - this.dragStart.x;
        let deltaY = mouseY - this.dragStart.y;
  
        // Adjust angles based on mouse movement
        this.angleX -= deltaX * 0.01; // Horizontal rotation
        this.angleY -= deltaY * 0.01; // Vertical rotation

  
        // Update dragStart to the current position for smooth dragging
        this.dragStart = { x: mouseX, y: mouseY };
      }
    }
  
    mouseReleased() {
      // Stop dragging when the mouse is rewleased
      this.dragStart = null;
    }
  
    mouseWheel(event) {
      this.zoomLevel += event.delta * 2; 
    }

    applyRotation() {
      // Apply rotation to the scene
      rotateX(this.angleY);
      rotateY(this.angleX);
    }
  }
  

let level; // Level object
let guiCanvas; // GUI canvas for 2D overlay
let mouseHandler; // MouseHandler object
let keyHandler; // KeyHandler object
let entities = []; // Array of sprites
let innerBox; // Controllable sprite


function setup() {
  // Create the WebGL canvas (primary canvas)
  createCanvas(windowWidth, windowHeight, WEBGL);

  // Create the GUI canvas for 2D overlay
  guiCanvas = createGraphics(windowWidth, windowHeight);

  // Initialize handlers
  mouseHandler = new MouseHandler();
  keyHandler = new KeyHandler();

  // Initialize level
  level = new Level(1024, 128, 1024);

  // Initialize controllable sprite (clairo)
  innerBox = new ControllableSprite(0, 32, 0, 32);

  // Initialize entities
  for (let i = 0; i < 10; i++) {
    // entities.push(new DeadTree(random(-400, 400), 32, random(-400, 400), 0, 0, 40, [139, 69, 19, 255], "Dead Tree"));
    entities.push(new DeadTree(random(-400, 400), 32, random(-400, 400), 0, 40, [139, 69, 19, 255], "Dead Tree"));
  }

}

function draw() {
  clear();
  background(50);

  ambientLight(100);
  pointLight(255, 255, 255, 0, 0, 300);
  // Add lights

  // Render 3D content
  push();
  translate(0, 0, mouseHandler.zoomLevel);
  mouseHandler.applyRotation();

  level.draw();
  innerBox.draw();
  
  for (let entity of entities) {
    entity.draw();
      // console.log("not clairo");
      entity.checkCollision(innerBox);
  }

  pop();
  handleMovement();
 
  // Update GUI layer
  drawUI();

  // Overlay GUI on top
  image(guiCanvas, -width/2, -height/2); // Position GUI layer
}

function drawUI() {
  let yOffset = 40;
  guiCanvas.clear();
  guiCanvas.fill(100, 170, 200);
  guiCanvas.textSize(16);

  // Display FPS
  guiCanvas.text(`FPS: ${Math.floor(frameRate())}`, 10, 20);

  // Display positions of entities
  guiCanvas.text(
    `${innerBox.name}: x: ${Math.floor(innerBox.x)}, z: ${Math.floor(innerBox.z)}}`,
    10,
    yOffset
  );
  yOffset += 20; // Move down for the next entity
  for (let entity of entities) {
    guiCanvas.text(
      `${entity.name}: x: ${Math.floor(entity.x)}, z: ${Math.floor(entity.z)}}`,
      10,
      yOffset
    );
    yOffset += 20;
  }
}


function handleMovement() {
  const movement = keyHandler.getMovement();
  const speed = 15;
  innerBox.moveWithDirection(movement, speed);
}

function keyPressed() {
  keyHandler.handleKeyPressed(key);
}

function keyReleased() {
  keyHandler.handleKeyReleased(key);
}

function mousePressed() {
  mouseHandler.mousePressed();
}

function mouseDragged() {
  mouseHandler.mouseDragged();
}

function mouseReleased() {
  mouseHandler.mouseReleased();
}

function mouseWheel(event) {
  mouseHandler.mouseWheel(event);
}




class Entity {
    constructor(x, y, z, size, color, name) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.size = size;
      this.color = color || [100, 200, 255, 150]; // Default color
      this.name = name || "Entity";
      this.circle_hitbox = circle(this.x, this.z, this.size);
    }
  
    move(dx, dy, dz) {
      this.x += dx;
      this.z -= dz;
    }
  
    draw() {
      // Draw the 3D representation of the sprite
      push();
      translate(this.x, 0, this.z);
      fill(...this.color);
      stroke(255);
      box(this.size);
      pop();
    }
  
    checkCollision(otherSprite) {
      let distance_between = dist(this.x, this.z, otherSprite.x, otherSprite.z);
      // if (this.sprite.collides(otherSprite.sprite)) {
      if (distance_between < this.size / 2 + otherSprite.size / 2) {
        console.log(`Collision detected between ${this.name} and ${otherSprite.name}`);
      }
    }
  
    
  }
  
class ControllableSprite extends Entity {
  constructor(x, y, z, size, color, name) {
    super(x, y, z, size, color, name); // Call the base class constructor
    this.name = "Clairo";
  }

  moveWithDirection(direction, speed) {
    let dx = 0, dz = 0;

    // Adjust movement based on direction
    if (direction.left) dx -= 1;
    if (direction.right) dx += 1;
    if (direction.up) dz -= 1;
    if (direction.down) dz += 1;

    // Check for diagonal movement and scale speed
    const isDiagonal = dx !== 0 && dz !== 0;
    /////////////////////////////////////////////////////////
    // might need to change this to flat number for faster speed

    const moveSpeed = isDiagonal ? speed / Math.sqrt(2) : speed;

    // Apply movement
    this.move(dx * moveSpeed, 0, dz * moveSpeed);
  }
}
  
class DeadTree extends Entity {
  constructor(x, y, z, size, color, name) {
    super(x, y, z, 40, [139, 69, 19, 255], "Dead Tree"); // Brownish color for dead tree
    // super(x, y, z, size, color, name); // Brownish color for dead tree
  }

  draw() {
    push();
    translate(this.x, 0, this.z);

    // Draw trunk
    fill(139, 69, 19); // Brown
    box(this.size / 4, this.size, this.size / 4);

    // Draw branches
    fill(160, 82, 45); // Lighter brown
    translate(0, -this.size / 2, 0);
    rotateZ(PI / 4);
    box(this.size / 8, this.size / 2, this.size / 8);
    rotateZ(-PI / 2);
    box(this.size / 8, this.size / 2, this.size / 8);

    pop();
  }
}



