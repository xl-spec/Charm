class KeyHandler {
    constructor() {
      this.movement = { left: false, right: false, up: false, down: false };
      this.action = false;
    }
  
    handleKeyPressed(key) {
      if (key === 'a') this.movement.left = true;
      if (key === 'd') this.movement.right = true;
      if (key === 'w') this.movement.up = true;
      if (key === 's') this.movement.down = true;
      if (key === 'e') this.action = true;
    }
  
    handleKeyReleased(key) {
      if (key === 'a') this.movement.left = false;
      if (key === 'd') this.movement.right = false;
      if (key === 'w') this.movement.up = false;
      if (key === 's') this.movement.down = false;
      if (key === 'e') this.action = false;
    }
  
    getMovement() {
      return this.movement;
    }

    getAction() {
      return this.action;
    }
  }
  

class Level {
    constructor(width, height, depth) {
      this.size = { width, height, depth };
    }
  
    draw() {
      push();
      translate(0, 0, 0); // Center the level at the origin
      noFill();
      stroke(255); // Outline color
      box(this.size.width, this.size.height, this.size.depth); // Render the container box
      pop();
    }
  }
  

class MouseHandler {
    constructor(camera) {
      this.dragStart = null;
      this.angleX = 0; // Horizontal rotation angle
      this.angleY = -60.4; // Vertical rotation angle
      this.zoomLevel = 20; // Initial zoom level
      // this.angleX = 20;
      // this.angleY = -60;
      // this.zoomLevel = 400;
      // this.angleX = 9;
      // this.angleY = -60;
      // this.zoomLevel = 400;
      // this.camera = camera; maybe add later idk
    }
  
    mousePressed() {
      // Track the initial mouse position on press
      this.dragStart = { x: mouseX, y: mouseY };
    }
  
    mouseDragged() {
      if (this.dragStart) {
        // Calculate the difference between the current and initial mouse positions
        let deltaX = mouseX - this.dragStart.x;
        let deltaY = mouseY - this.dragStart.y;
  
        // Adjust angles based on mouse movement
        this.angleX -= deltaX * 0.01; // Horizontal rotation
        this.angleY -= deltaY * 0.01; // Vertical rotation

        // Update dragStart to the current position for smooth dragging
        this.dragStart = { x: mouseX, y: mouseY };
      }
    }
  
    mouseReleased() {
      this.dragStart = null;
    }
  
    mouseWheel(event) {
      this.zoomLevel += event.delta * 2; 
    }

    applyRotation() {
      rotateX(this.angleY);
      rotateY(this.angleX);
    }
  }
  

let level; // Level object
let guiCanvas; // GUI canvas for 2D overlay
let mouseHandler; // MouseHandler object
let keyHandler; // KeyHandler object
let entities = []; // Array of sprites
let player; // Controllable sprite

// O_O
function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);

  // gui
  guiCanvas = createGraphics(windowWidth, windowHeight);

  // input handlers
  mouseHandler = new MouseHandler();
  keyHandler = new KeyHandler();
  settings = new Settings();

  // Initialize level
  level = new Level(settings.LEVEL_WIDTH, settings.LEVEL_HEIGHT, settings.LEVEL_DEPTH);
  player = new ControllableSprite(settings.PLAYER_START_X, settings.PLAYER_START_Y, settings.PLAYER_START_Z, settings.PLAYER_START_SIZE);

  for (let i = 0; i < 20; i++) {
    entities.push(new Tree(random(-400, 400), 32, random(-400, 400), 32, [139, 69, 19, 255], "Dead Tree"));
  }

  for (let i = 0; i < 10; i++) {
    entities.push(new Snowman(random(-400, 400), 32, random(-400, 400), 32, [139, 69, 19, 255], "Snowman"));
  }
}

function draw() {
  clear();
  background(50);

  ambientLight(100);
  pointLight(255, 255, 255, 0, 0, 300);

  push();

  translate(0, 0, mouseHandler.zoomLevel);
  mouseHandler.applyRotation();
  // orbitControl(3, 3, 3);

  level.draw();
  player.draw();
  player.axe.update();
  
  for (let entity of entities) {
    entity.draw();
    // entity.checkCollision(player);
    entity.checkCollisionAxe(player.axe);
  }

  pop();

  handleMovement();
  handleAction();

  drawUI();
  image(guiCanvas, -width/2, -height/2); // Position GUI layer
}

function drawUI() {
  let yOffset = 40;
  guiCanvas.clear();
  guiCanvas.fill(100, 170, 200);
  guiCanvas.textSize(16);

  // Display FPS
  guiCanvas.text(`FPS: ${Math.floor(frameRate())}`, 10, 20);

  // Display positions of entities
  guiCanvas.text(
    `${player.name}: x: ${Math.floor(player.x)}, z: ${Math.floor(player.z)}`,
    10,
    yOffset
  );
  yOffset += 20; // Move down for the next entity
  for (let entity of entities) {
    guiCanvas.text(
      `${entity.name}: x: ${Math.floor(entity.x)}, z: ${Math.floor(entity.z)}`,
      10,
      yOffset
    );
    yOffset += 20;
  }
}


function handleMovement() {
  const movement = keyHandler.getMovement();
  const speed = 10;
  player.moveWithDirection(movement, speed);
}

function handleAction(){
  if (keyHandler.getAction()){
    player.axe.startAttack();
  }
}

function keyPressed() {
  keyHandler.handleKeyPressed(key);
}

function keyReleased() {
  keyHandler.handleKeyReleased(key);
}

function mousePressed() {
  mouseHandler.mousePressed();
}

function mouseDragged() {
  mouseHandler.mouseDragged();
}

function mouseReleased() {
  mouseHandler.mouseReleased();
}

function mouseWheel(event) {
  mouseHandler.mouseWheel(event);
}




class Entity {
    constructor(x, y, z, size, color, name) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.size = size;
      this.color = color || [100, 200, 255, 150]; // Default color
      this.name = name || "Entity";
      this.hitbox_visible = true;
      this.face_direction = [0, 0];
    }
  
    move(dx, dy, dz) {
      this.x += dx;
      this.z -= dz;
    }
  
    draw() { // maybe rename/rewrite this, this is just a hitbox applied to all sprites
      // this is a circle that represents the hitbox of the entity
      if (this.hitbox_visible){
        push();
          translate(this.x, -65, this.z);
          rotateX(HALF_PI);
          noStroke();
          fill(255, 0, 0, 100);
          ellipse(0, 0, this.size, this.size);
        pop();

      }

    }
    // might need to... make this an entire class to handle all the different types of collisions
    checkCollision(otherSprite) { // formula for circle collsion
      let distance_between = dist(this.x, this.z, otherSprite.x, otherSprite.z);
      if (distance_between < this.size / 2 + otherSprite.size / 2) {
        console.log(`Collision detected between ${this.name} and ${otherSprite.name}`);
      }
    }

    checkCollisionAxe(axe) {
      if (!axe.isAttacking) return;

      for (let i = 0; i < axe.num_hitboxes; i++) {
        let d = dist(axe.hitbox_map[i]['x'], axe.hitbox_map[i]['z'], this.x, this.z);
        if (d  < this.size / 2 + 2) {
          console.log(`Axe collided with ${this.name}!`);
        }
      }
    }
  }
  
class ControllableSprite extends Entity {
  constructor(x, y, z, size, color, name) {
    super(x, y, z, size, color, name); // Call the base class constructor
    this.name = "Character";
    this.hitbox_visible = true;
    this.hit_action = false;
    this.axe = new Axe("Wood Axe", this);
  }

  moveWithDirection(direction, speed) {
    //////////////////////////
    // lock movement if in action,
    let dx = 0, dz = 0;

    // Adjust movement based on direction
    if (direction.left) dx -= 1;
    if (direction.right) dx += 1;
    if (direction.up) dz -= 1;
    if (direction.down) dz += 1;

    // Check for diagonal movement and scale speed
    const isDiagonal = dx !== 0 && dz !== 0;
    const moveSpeed = isDiagonal ? speed / 1.414 : speed; // good enough

    this.move(dx * moveSpeed, 0, dz * moveSpeed);
  }

  draw(){
    super.draw();

    push();
      translate(this.x, 0, this.z);
      fill(...this.color);
      stroke(255);
      cone(this.size / 2, this.size);
    pop();

    this.axe.draw();
  }
}
  
class Tree extends Entity {
  constructor(x, y, z, size, color, name) {
    super(x, y, z, size, color, name);
  }

  draw() {
    super.draw();
    push();
      translate(this.x, 0, this.z);

      // trunk
      fill(139, 69, 19); // Brown
      box(this.size / 4, this.size, this.size / 4);

      // branches
      fill(160, 82, 45); // Lighter brown
      translate(0, -this.size / 2, 0);
      rotateZ(PI / 4);
      box(this.size / 8, this.size / 2, this.size / 8);
      rotateZ(-PI / 2);
      box(this.size / 8, this.size / 2, this.size / 8);

      // will do more later
      // thinking of doing trunk, 4-8 branches
    pop();
  }
}

class Snowman extends Entity{
  // two attacks, one requires snow ammo and throws snowball at character, other is just a mini weak lunge
  constructor(x, y, z, size, color, name){
    super(x, y, z, size, color, name);
  }
s
  draw(){
    super.draw();
    push();
      translate(this.x, 30, this.z);
      fill(0, 0, 0);
      sphere(this.size / 4, 64, 8);
    pop();

    push();
    translate(this.x, 18, this.z);
    fill(255);
    sphere(this.size / 3, 64, 8);
    pop();

    push();
      translate(this.x, 0, this.z);
      fill(255);
      sphere(this.size / 2, 64, 8);
    pop();
  }
}

